/*
Итак, у нас тут появилось Cons и Nil штука.
*/
use std::ops::Deref;
use std::rc::Rc;

/*
Интересная тут штука блин.

Рекурсия прямо в типе? Да пожалуйста.

Почему именно рeкурсия? Да потому что у нас Box ссылается на еще один enum List,
а тот List имеется такой же Box<List> внутри и т.д.

Конец рекурсии тут означает тип Nil. А ее начало как я понял Cons штука.
Да чего же мощный Rust...
*/
enum List {
    Cons(i32, Box<List>),
    Nil,
}

// Собственная штука Box. Но только данные на самом деле хранятся в стеке.
// Здесь мы используем обобщенный параметр  типа T.
//
// Мне будет удобнее тут говорить про T как аналогию с шаблонами в C++.
// Однако скорее всего эта аналогия не совсем верная.
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

// Интересно, а для чего нам тут делают type Target = T?
// Опять что-ли, чтобы показать насколько мощный Rust?
// Нет сомнений, что он мощный. Но...
//
// Мне кажется можно было тут и просто -> &T использовать.
impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
        // Rust позволяет обратится к элементу структуры по "индексу"
    }
}

impl<T> Drop for MyBox<T> {
    fn drop(&mut self) {
        // Почему mut? А потому что свойство будет изменено у объекта?
        println!("Dropping MyBox.");
    }
}

use crate::rusti_pointer::List::{Cons, Nil};

fn print_value(list: &List) -> &List {
    match list {
        Cons(x, y) => {
            println!("{} - {:p}", x, y);
            &**y // Почему два *? Потому что: [&Box<List>] - & раз, Box два
        }
        Nil => {
            println!("Nil.");
            &Nil
        }
    }
}

fn lol_print(m: &i32) {
    println!("Addr on MyBox on lol_print: {m:p}");
}

pub fn test() {
    /*
    Box хранит данные в куче. Это все, что нужно знать.

    Но сам Box в данном случае в стеке.
    */
    let b = Box::new(10);

    println!("b = {b}");

    /*
    Рекурсивный список? Хм...
    */
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    let mut value = print_value(&list);

    // После 3 будет только Nil.
    for _ in 0..5 {
        value = print_value(&value);
    }

    let my = MyBox::new(10);

    println!("{}", *my);

    println!("Addr on MyBox: {:p}", &my);
    lol_print(&my);

    // Одинаковые адреса? WTF? У нас же разные типы.
    //
    // Тут дело в том, как Rust выделяет память.
    //
    // У нас структура (my), которая состоит только из поля x (i32).
    // Структура это не больше, чем абстракция для области памяти.
    // Соотв. начало области памяти для my будет являться первое ее
    // поле, то есть x.
    drop(my); // Можно явно вызвать Drop, но только через drop.
    // Однако drop будет вызван неявно каждый раз, когда переменная
    // покинет область видимости.

    // Rc это можно сказать местный аналог shared_ptr из C++.
    //
    // Он допускает множественное владение одним элементом, но, реализуется
    // это через подсчет ссылок.
    let a = Rc::new(10);
    let b = Rc::clone(&a);
    let c = Rc::clone(&a);

    // Смотрим адреса памяти...
    // Интересно. Вроде по идеи переменные же в стеке?
    // Они должны быть различными, видимо это и есть то самое
    // множественное владение.
    //
    // Да, как говорят в учебнике его можно было сделать и через
    // ссылки. Но тогда придется указывать время жизни ссылки, а
    // тут можно обойтись без этого.
    println!("{:p} == {:p} == {:p}", a, b, c);

    // Есть еще Refcell умный указатель.
    // Однако он там проверяет такие же правила заимствования, но уже на
    // этапе выполнения программы. Не на этапе компиляции.
    //
    // Тут я не буду его демонстрировать, не сильно понимаю, какой
    // бы кейс по лучше разобрать. Думаю, еще столкнусь с ним.

    // Еще есть указатель Weak (слабая ссылка).
    // Он нужен, когда у нас возможны циклические ссылки.
    // Отличие от остальных указателей в том, что этот указатель не владеет
    // объектом.
    // Чтобы получить доступ к объекту, на который он ссылается нужно явно
    // вызвать метод. Но при этом даже если объект, на который он ссылается
    // уже уничтожен в памяти, то никаких ошибок не будет, метод просто
    // вернет None.

    println!("Drop value?");
    // Конец области видимости, но второй раз тут drop не будет вызван.
    // Если бы был вызван, была бы одна из веселых ошибок double-free.
}

// Из книги:
// Rust выполняет разыменованное приведение, когда находит типы и реализации типажей
// в трёх случаях:
// Из типа &T в тип &U когда верно T: Deref<Target=U>
// Из типа &mut T в тип &mut U когда верно T: DerefMut<Target=U>
// Из типа &mut T в тип &U когда верно T: Deref<Target=U>
