/*
Короче, мне капец не привычно вводить в свою голову термин "замыкание"
поэтому тут буду использовать его как "анонимные функции".

Надеюсь, меня не разорвут на части, let's see!
*/

pub fn test() {
    /*
    Мне не ясно тут только одно. А почему не в () параметры?
    Почему именно в ||?
    Забавно.
    */
    let lol = || {
        2
    };

    let m = |x: i64| {
        x+9
    };

    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);
    // let mm = || println!("{:?}", list);
    /*
    Данный код не скомпилируется ввиду того, что:
    Между определением замыкания и вызовом замыкания 
    неизменяемое заимствование для печати недоступно, 
    потому что при наличии изменяемого заимствования 
    никакие другие заимствования недопустимы.


    Ну емае. Терминалогия Rust... да блин!
    */
    borrows_mutably();
    println!("After calling closure: {:?}", list);

    println!("Anonym func: {}", lol());
    println!("Anonym func with x param: {}", m(20));

    /*
    Если вы хотите заставить замыкание принять владение значениями, 
    которые оно использует в окружении, 
    даже если в теле замыкания нет кода, требующего владения,
    вы можете использовать ключевое слово move перед
    списком параметров.
    
    То есть:
    */
    let ohoho = vec![1, 2, 3];

    let oho = move || println!("{:?}", ohoho);

    oho();
    // println!("{:?}", ohoho);
    /*
    ^^^ Это не скомпилируется. Так как ohoho теперь владеет
    oho анонимная функция. 

    Но если бы вместо вектора у нас был бы тип, который
    реализует Copy, то этот код бы скомпилировался.

    Дело в том, что в типах с Copy Rust КОПИРУЕТ значения, а не
    передает их в владение какому-либо элементу.

    Иными словами:
    Если тип реализует Copy, то с move этот тип просто будет
    копироваться.
    Иначе же передается владение. 

    Если бы мы тут не взяли move, то значение бы передалось по 
    ссылке.

    Проверить можно через этот код:
    println!("{:p}", &ohoho);
    let oho = || println!("{:p}", &ohoho);

    Здесь адреса памяти совпадают.

    Если же мы бы сделали такой код:
    let ohoho = 10;

    println!("{:p}", &ohoho);
    let oho = move || println!("{:p}", &ohoho);

    Адреса памяти будут различны, что и требовалось ожидать. 
    Так как:
    > Если тип реализует Copy, то с move этот тип просто будет
    копироваться.
    */
}
